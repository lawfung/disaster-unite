import{ac as w,C as k,A as g,a as A,ad as m,b as f,c as W,h as C,G as T,g as v,d as y,l as I,V as E,X as R,o as d,ae as $,u as h,T as c,y as b,K as u}from"./index.de57dce4.js";import{h as S}from"./hasERC20Allowance-1499f181.browser.esm.9e60d23f.js";import{S as P}from"./erc-721-standard-c858f30e.browser.esm.838199b0.js";class l extends P{static contractRoles=w;constructor(r,e,n){let s=arguments.length>3&&arguments[3]!==void 0?arguments[3]:{},t=arguments.length>4?arguments[4]:void 0,a=arguments.length>5?arguments[5]:void 0,o=arguments.length>6&&arguments[6]!==void 0?arguments[6]:new k(r,e,t,s,n);super(o,n,a),this.abi=g.parse(t||[]),this.metadata=new A(this.contractWrapper,m,this.storage),this.app=new f(this.contractWrapper,this.metadata,this.storage),this.roles=new W(this.contractWrapper,l.contractRoles),this.encoder=new C(this.contractWrapper),this.estimator=new T(this.contractWrapper),this.events=new v(this.contractWrapper),this.royalties=new y(this.contractWrapper,this.metadata),this.owner=new I(this.contractWrapper)}async getWrappedContents(r){const e=await this.contractWrapper.read("getWrappedContents",[r]),n=[],s=[],t=[];for(const a of e)switch(a.tokenType){case 0:{const o=await E(this.contractWrapper.getProvider(),a.assetContract);n.push({contractAddress:a.assetContract,quantity:R(a.totalAmount,o.decimals)});break}case 1:{s.push({contractAddress:a.assetContract,tokenId:a.tokenId});break}case 2:{t.push({contractAddress:a.assetContract,tokenId:a.tokenId,quantity:a.totalAmount.toString()});break}}return{erc20Tokens:n,erc721Tokens:s,erc1155Tokens:t}}wrap=d(async(r,e,n)=>{const s=await $(e,this.storage),t=await h(n||await this.contractWrapper.getSignerAddress()),a=await this.toTokenStructList(r);return c.fromContractWrapper({contractWrapper:this.contractWrapper,method:"wrap",args:[a,s,t],parse:o=>{const i=this.contractWrapper.parseLogs("TokensWrapped",o?.logs);if(i.length===0)throw new Error("TokensWrapped event not found");const p=i[0].args.tokenIdOfWrappedToken;return{id:p,receipt:o,data:()=>this.get(p)}}})});unwrap=d(async(r,e)=>{const n=await h(e||await this.contractWrapper.getSignerAddress());return c.fromContractWrapper({contractWrapper:this.contractWrapper,method:"unwrap",args:[r,n]})});async toTokenStructList(r){const e=[],n=this.contractWrapper.getProvider(),s=await this.contractWrapper.getSignerAddress();if(r.erc20Tokens)for(const t of r.erc20Tokens){const a=await b(n,t.quantity,t.contractAddress);if(!await S(this.contractWrapper,t.contractAddress,a))throw new Error(`ERC20 token with contract address "${t.contractAddress}" does not have enough allowance to transfer.

You can set allowance to the multiwrap contract to transfer these tokens by running:

await sdk.getToken("${t.contractAddress}").setAllowance("${this.getAddress()}", ${t.quantity});

`);e.push({assetContract:t.contractAddress,totalAmount:a,tokenId:0,tokenType:0})}if(r.erc721Tokens)for(const t of r.erc721Tokens){if(!await u(this.contractWrapper.getProvider(),this.getAddress(),t.contractAddress,t.tokenId,s))throw new Error(`ERC721 token "${t.tokenId}" with contract address "${t.contractAddress}" is not approved for transfer.

You can give approval the multiwrap contract to transfer this token by running:

await sdk.getNFTCollection("${t.contractAddress}").setApprovalForToken("${this.getAddress()}", ${t.tokenId});

`);e.push({assetContract:t.contractAddress,totalAmount:0,tokenId:t.tokenId,tokenType:1})}if(r.erc1155Tokens)for(const t of r.erc1155Tokens){if(!await u(this.contractWrapper.getProvider(),this.getAddress(),t.contractAddress,t.tokenId,s))throw new Error(`ERC1155 token "${t.tokenId}" with contract address "${t.contractAddress}" is not approved for transfer.

You can give approval the multiwrap contract to transfer this token by running:

await sdk.getEdition("${t.contractAddress}").setApprovalForAll("${this.getAddress()}", true);

`);e.push({assetContract:t.contractAddress,totalAmount:t.quantity,tokenId:t.tokenId,tokenType:2})}return e}async prepare(r,e,n){return c.fromContractWrapper({contractWrapper:this.contractWrapper,method:r,args:e,overrides:n})}async call(r,e,n){return this.contractWrapper.call(r,e,n)}}export{l as Multiwrap};
